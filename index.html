<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Three.js - Shadertoy Example - CDN</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.js"
        }
      }
    </script>
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>

  <script type="module">
    // Three.js - Shadertoy Prep
    // from https://threejs.org/manual/examples/shadertoy-prep.html

    import * as THREE from 'three'

    const uniforms = {
      iTime: { value: 0 },
      iResolution: { value: new THREE.Vector3() }
    }

    const shaderCode = prompt(
      'Paste your shadertoy code',
      `void mainImage( out vec4 O, vec2 u ) {
    vec2 R = iResolution.xy,
         U = (u+u - R ) / R.y;
    O *= 0.;
    
    for ( float l = length(U), d, i = 0.; i < 4.; i++)
        U = fract(U * 1.5) - .5,
        d = length(U) * exp(-l),
        d = pow(abs( .08 / sin(d*8. + iTime) ) , 1.2),
        O += d * ( .5 + .5*cos( 6.28*(l + i*.4 + iTime*.4 +vec4(.26,.42,.56,0) ) ) );
}`)

    const fragmentShader = `
#include <common>
 
uniform vec3 iResolution;
uniform float iTime;
 

${shaderCode}
 
void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
`

    function main() {
      const canvas = document.querySelector('#c')
      const renderer = new THREE.WebGLRenderer({ antialias: true, canvas })
      renderer.autoClearColor = false

      const camera = new THREE.OrthographicCamera(
        -1, // left
        1, // right
        1, // top
        -1, // bottom
        -1, // near,
        1 // far
      )
      const scene = new THREE.Scene()
      const plane = new THREE.PlaneGeometry(2, 2)
      const material = new THREE.ShaderMaterial({
        fragmentShader,
        uniforms
      })
      scene.add(new THREE.Mesh(plane, material))

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement
        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      function render(time) {
        time *= 0.001 // convert to seconds

        resizeRendererToDisplaySize(renderer)

        const canvas = renderer.domElement
        uniforms.iResolution.value.set(canvas.width, canvas.height, 1)
        uniforms.iTime.value = time
        resizeRendererToDisplaySize(renderer)

        renderer.render(scene, camera)

        requestAnimationFrame(render)
      }

      requestAnimationFrame(render)
    }

    main()
  </script>
</html>
